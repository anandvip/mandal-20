<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meditation Mandal Tracker v16</title>
    <link rel="stylesheet" href="styles.css">
    <style>

        .session-controls {
    display: flex;
    justify-content: flex-end;
    margin-top: 10px;
}

.delete-btn.danger-red {
    background-color: #dc3545;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
}

.delete-btn.danger-red:hover {
    background-color: #c82333;
}

.editable-notes {
    border: 1px solid #ccc;
    padding: 10px;
    min-height: 50px;
    margin-top: 10px;
}

.editable-notes:empty:before {
    content: 'Add notes here...';
    color: #999;
}
    </style>
</head>
<body>
    <div class="container">
        <h1>Meditation <span class="logo">Mandal Tracker</span></h1>
        <h2>Namaskaram, <span id="userName" contenteditable="true" aria-label="Your name" class="logo">Your Name</span>!</h2>
        <button id="themeToggle" aria-label="Toggle dark mode">Toggle Dark Mode</button>
        <button id="giveFeedback" aria-label="Give feedback">Give Feedback</button>
        <button id="addPastSession" aria-label="Add past session">Add Past Session</button>
        <button id="printPage" aria-label="Print Page">Print Page</button>

        <div id="mandalCreation" class="card">
            <h2>Create New Mandal</h2>
            <input type="text" id="mandalName" placeholder="Mandal Name" aria-label="Mandal Name">
            <select id="mandalDuration" aria-label="Mandal Duration">
                <option value="48">48 Days</option>
                <option value="90">90 Days</option>
            </select>
            <input type="date" id="startDate" aria-label="Start Date">
            <button id="createMandal" aria-label="Create Mandal">Create Mandal</button>
        </div>

        <div id="activeMandalInfo" class="card" style="display: none;">
            <h2>Active Mandal: <span id="activeMandalName"></span></h2>
            <div id="dashboard" aria-live="polite"></div>
            <div class="dashboard-item">
                <h3>Current Session</h3>
                <div id="timer" aria-live="polite">00:00:00</div>
                <div class="timer-controls">
                    <button id="startSession" aria-label="Start Session">Start Session</button>
                    <button id="stopSession" style="display: none;" aria-label="Stop Session">Stop Session</button>
                </div>
            </div>
        </div>

        <div class="media-embed">
            <h3>Meditation Media</h3>
            <input type="text" id="mediaUrl" placeholder="Enter YouTube or SoundCloud URL" aria-label="Media URL">
            <button id="embedMedia" aria-label="Embed Media">Embed Media</button>
            <div id="mediaContainer"></div>
        </div>

        <div id="sessionHistory" class="card" style="display: none;">
            <h2>Session History</h2>
            <div id="historyControls">
                <div>
                    <input type="text" id="searchInput" placeholder="Search notes..." aria-label="Search notes">
                    <button id="sortByDate" aria-label="Sort by Date">Sort by Date</button>
                </div>
            </div>
            <div id="formatButtons">
                     <div id="stickyFormatNav" class="sticky-format-nav">
            <button onclick="applyFormat('bold')" aria-label="Bold">B</button>
            <button onclick="applyFormat('italic')" aria-label="Italic">I</button>
            <button onclick="applyFormat('underline')" aria-label="Underline">U</button>
            <button onclick="applyFormat('strikeThrough')" aria-label="Strike Through">S</button>
            <button onclick="applyFormat('removeFormat')" aria-label="Remove Formatting">Remove</button>
        </div>
            </div>
            <div id="historyContent" aria-live="polite"></div>
        </div>

        <div id="pastSessionModal" class="modal" aria-hidden="true">
            <div class="modal-content">
                <span class="close" aria-label="Close">&times;</span>
                <h2>Add Past Sessions</h2>
                <form id="pastSessionForm">
                    <label for="pastDate">Date:</label>
                    <input type="date" id="pastDate" required aria-label="Past session date">
                    <div>
                        <label>
                            <input type="checkbox" id="morningSession" checked aria-label="Morning session"> Morning Session
                        </label>
                    </div>
                    <div>
                        <label>
                            <input type="checkbox" id="eveningSession" checked aria-label="Evening session"> Evening Session
                        </label>
                    </div>
                    <button type="submit" aria-label="Add Sessions">Add Sessions</button>
                </form>
            </div>
        </div>

        <div id="feedbackModal" class="modal" aria-hidden="true">
            <div class="modal-content">
                <span class="close" aria-label="Close">&times;</span>
                <h2>Provide Feedback</h2>
                <textarea id="feedbackText" rows="4" placeholder="Enter your feedback here..." aria-label="Feedback text"></textarea>
                <button id="submitFeedback" aria-label="Submit Feedback">Submit Feedback</button>
            </div>
        </div>

        <div id="toast" class="toast" aria-live="assertive"></div>
    </div>

        <button id="backToTop" aria-label="Back to top" title="Back to top">â†‘</button>
  
<script>
  
  // Constants
const SESSION_DURATION = 873; // 14 minutes and 33 seconds in seconds
const TOTAL_SESSIONS = 96; // 48 days * 2 sessions per day

// Utility Functions
const formatDate = (date) => {
    return date.toLocaleDateString('en-GB', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
    });
};

const formatTime = (seconds) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    return `${pad(hours)}:${pad(minutes)}:${pad(secs)}`;
};

const pad = (num) => num.toString().padStart(2, '0');

const sanitizeHTML = (str) => {
    const temp = document.createElement('div');
    temp.textContent = str;
    const sanitized = temp.innerHTML;
    // Allow only specific HTML tags
    return sanitized.replace(/&lt;(\/?)(b|i|u|strike)&gt;/g, '<$1$2>');
};

const getSessionTime = (date) => {
    const hours = date.getHours();
    return hours < 12 ? 'Morning' : 'Evening';
};

// MeditationStore Class
class MeditationStore {
    constructor() {
        this.state = {
            activeMandal: null,
            sessions: [],
            sortAscending: true,
            theme: 'light',
            timerRunning: false,
            timerSeconds: 0,
            userName: 'Your Name'
        };
        this.observers = [];
        this.timerInterval = null;
        this.timerStartTime = null;
    }

    addObserver(observer) {
        this.observers.push(observer);
    }

    notifyObservers() {
        this.observers.forEach(observer => observer.update(this.state));
    }

    setState(newState) {
        this.state = { ...this.state, ...newState };
        this.saveToLocalStorage();
        this.notifyObservers();
    }

    createMandal(mandalData) {
        if (this.state.activeMandal) {
            throw new Error("An active Mandal already exists. Please complete or delete it before creating a new one.");
        }
        this.setState({ activeMandal: mandalData, sessions: [] });
    }

    addSession(sessionData) {
        this.setState({
            sessions: [...this.state.sessions, sessionData],
            currentStreak: this.calculateStreak()
        });
    }

    deleteSession(index) {
        const newSessions = [...this.state.sessions];
        newSessions.splice(index, 1);
        this.setState({
            sessions: newSessions,
            currentStreak: this.calculateStreak()
        });
    }

    updateSessionNotes(index, notes) {
        const newSessions = [...this.state.sessions];
        newSessions[index].notes = notes;
        this.setState({ sessions: newSessions });
    }

    toggleSortOrder() {
        this.setState({ sortAscending: !this.state.sortAscending });
    }

    toggleTheme() {
        const newTheme = this.state.theme === 'light' ? 'dark' : 'light';
        this.setState({ theme: newTheme });
        document.body.classList.toggle('dark-mode', newTheme === 'dark');
    }

    saveToLocalStorage() {
        localStorage.setItem('meditationTrackerState', JSON.stringify(this.state));
    }

    loadFromLocalStorage() {
        const savedState = JSON.parse(localStorage.getItem('meditationTrackerState'));
        if (savedState) {
            if (savedState.activeMandal) {
                savedState.activeMandal.startDate = new Date(savedState.activeMandal.startDate);
                savedState.activeMandal.endDate = new Date(savedState.activeMandal.endDate);
            }
            savedState.sessions = savedState.sessions.map(session => ({
                ...session,
                date: new Date(session.date)
            }));
            this.setState(savedState);
        }
    }

    calculateStreak() {
        if (this.state.sessions.length === 0) return 0;
        let streak = 0;
        let currentDate = new Date();
        currentDate.setHours(0, 0, 0, 0);

        const sortedSessions = [...this.state.sessions].sort((a, b) => b.date - a.date);

        for (let i = 0; i < sortedSessions.length; i++) {
            const sessionDate = new Date(sortedSessions[i].date);
            sessionDate.setHours(0, 0, 0, 0);

            const dayDifference = Math.round((currentDate - sessionDate) / (1000 * 60 * 60 * 24));

            if (dayDifference === streak) {
                streak++;
                currentDate = sessionDate;
            } else if (dayDifference > streak) {
                break;
            }
        }

        return streak;
    }

    getWeeklyStats() {
        const oneWeekAgo = new Date();
        oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
        const weekSessions = this.state.sessions.filter(session => session.date >= oneWeekAgo);
        const totalTime = weekSessions.reduce((sum, session) => sum + session.duration, 0);
        const averageTime = weekSessions.length > 0 ? totalTime / weekSessions.length : 0;
        return {
            sessionsCount: weekSessions.length,
            totalTime,
            averageTime
        };
    }

    searchNotes(query) {
        const lowercaseQuery = query.toLowerCase();
        return this.state.sessions.filter(session =>
            session.notes.toLowerCase().includes(lowercaseQuery)
        );
    }

    startTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
        }

        this.timerStartTime = Date.now();
        this.setState({ timerRunning: true, timerSeconds: 0 });

        this.timerInterval = setInterval(() => {
            const elapsedSeconds = Math.floor((Date.now() - this.timerStartTime) / 1000);
            this.setState({ timerSeconds: elapsedSeconds });

            if (elapsedSeconds >= SESSION_DURATION) {
                this.stopTimer();
            }
        }, 1000);
    }

    stopTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }

        const elapsedSeconds = Math.floor((Date.now() - this.timerStartTime) / 1000);
        const duration = Math.min(elapsedSeconds, SESSION_DURATION);

        this.addSession({
            date: new Date(this.timerStartTime),
            duration: duration,
            notes: ''
        });

        this.setState({ timerRunning: false, timerSeconds: 0 });
        this.timerStartTime = null;
    }

    cleanup() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
    }

    setUserName(name) {
        this.setState({ userName: name });
    }
}

// UI Update Functions
function updateDashboard(state) {
    const { activeMandal, sessions } = state;
    if (!activeMandal) return;

    const dashboardElement = document.getElementById('dashboard');
    const now = new Date();
    const totalDays = (activeMandal.endDate - activeMandal.startDate) / (1000 * 60 * 60 * 24);
    const daysPassed = Math.max(0, Math.min(totalDays, (now - activeMandal.startDate) / (1000 * 60 * 60 * 24)));
    const progress = Math.round((daysPassed / totalDays) * 100);

    const totalTime = sessions.reduce((sum, session) => sum + session.duration, 0);
    const sessionsCount = sessions.length;

    const streak = store.calculateStreak();
    const weeklyStats = store.getWeeklyStats();

    dashboardElement.innerHTML = `
        <div class="dashboard-item">
            <h3>Mandal Progress</h3>
            <div class="circular-progress" role="progressbar" aria-valuenow="${progress}" aria-valuemin="0" aria-valuemax="100">
                <svg viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="45" fill="none" stroke="#e0e0e0" stroke-width="10" />
                    <circle cx="50" cy="50" r="45" fill="none" stroke="var(--primary-color)" stroke-width="10" stroke-dasharray="${progress * 2.83} 283" />
                </svg>
                <div class="circular-progress-text">${progress}%</div>
            </div>
            <p>Start Date: ${formatDate(activeMandal.startDate)}</p>
            <p>End Date: ${formatDate(activeMandal.endDate)}</p>
            <p>Days Remaining: ${Math.max(0, Math.ceil(totalDays - daysPassed))}</p>
        </div>
        <div class="dashboard-item">
            <h3>Session Statistics</h3>
            <div class="circular-progress" role="progressbar" aria-valuenow="${sessionsCount}" aria-valuemin="0" aria-valuemax="${TOTAL_SESSIONS}">
                <svg viewBox="0 0 100 100">
                    <circle cx="50" cy="50" r="45" fill="none" stroke="#e0e0e0" stroke-width="10" />
                    <circle cx="50" cy="50" r="45" fill="none" stroke="var(--secondary-color)" stroke-width="10" stroke-dasharray="${(sessionsCount / TOTAL_SESSIONS) * 283} 283" />
                </svg>
                <div class="circular-progress-text">${sessionsCount}/${TOTAL_SESSIONS}</div>
            </div>
            <p>Total Meditation Time: ${formatTime(totalTime)}</p>
            <p>Average Session Duration: ${formatTime(totalTime / sessionsCount || 0)}</p>
        </div>
        <div class="dashboard-item">
            <h3>Current Streak</h3>
            <div class="streak-display">
                <span id="currentStreak">${streak}</span> days
            </div>
        </div>
        <div class="dashboard-item">
            <h3>This Week's Progress</h3>
            <p>Sessions: ${weeklyStats.sessionsCount}</p>
            <p>Total Time: ${formatTime(weeklyStats.totalTime)}</p>
            <p>Average Time: ${formatTime(weeklyStats.averageTime)}</p>
        </div>
        <div class="dashboard-item">
            <h3>Quick Add</h3>
            <button id="addTodaySession" aria-label="Add Session for Today">Add Session for Today</button>
        </div>
    `;

    document.getElementById('activeMandalName').textContent = activeMandal.name;
    document.getElementById('addTodaySession').addEventListener('click', handleAddTodaySession);
}

function displaySessionHistory(state, searchQuery = '') {
    const { sessions, sortAscending } = state;
    const historyContent = document.getElementById('historyContent');
    
    if (sessions.length === 0) {
        historyContent.innerHTML = "<p>No meditation sessions recorded yet.</p>";
        return;
    }

    const sortedSessions = [...sessions].sort((a, b) => 
        sortAscending ? a.date - b.date : b.date - a.date
    );

    historyContent.innerHTML = sortedSessions.map((session, index) => `
        <div class="session-entry">
            <div class="session-header">
                <span class="session-time">${session.period || getSessionTime(session.date)}</span><br>
                <span class="session-date">${formatDate(session.date)} - ${formatTime(session.duration)}</span>
            </div>
            <div class="editable-notes" contenteditable="true" data-index="${index}" onblur="handleSaveNotes(event)" aria-label="Session notes">
                ${session.notes ? highlightSearchTerm(session.notes, searchQuery) : 'Add notes here...'}
            </div>
            <div class="session-controls">
                <button class="delete-btn danger-red" onclick="handleDeleteSession(${index})" aria-label="Delete Session">Delete Session</button>
            </div>
        </div>
    `).join('');
}

    // Make the format nav sticky
    const stickyFormatNav = document.getElementById('stickyFormatNav');
    const sticky = stickyFormatNav.offsetTop;
    window.onscroll = function() {
        if (window.pageYOffset > sticky) {
            stickyFormatNav.classList.add("sticky");
        } else {
            stickyFormatNav.classList.remove("sticky");
        }
    };
}

function highlightSearchTerm(text, searchTerm) {
    if (!searchTerm) return text;
    const regex = new RegExp(`(${searchTerm})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
}

function updateTimerDisplay(seconds) {
    const timerElement = document.getElementById('timer');
    timerElement.textContent = formatTime(seconds);
}

function updateTimerControls(timerRunning) {
    const startButton = document.getElementById('startSession');
    const stopButton = document.getElementById('stopSession');
    startButton.style.display = timerRunning ? 'none' : 'inline-block';
    stopButton.style.display = timerRunning ? 'inline-block' : 'none';
}

// Event Handlers
function handleCreateMandal() {
    const name = document.getElementById('mandalName').value.trim();
    const duration = parseInt(document.getElementById('mandalDuration').value);
    const startDate = new Date(document.getElementById('startDate').value);
    
   if (!name || isNaN(startDate.getTime())) {
        showToast('Please enter a valid Mandal name and start date.');
        return;
    }
    
    const endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + duration);
    
    store.createMandal({ name, startDate, endDate, duration });
    showToast('Mandal created successfully!');
    
    document.getElementById('activeMandalInfo').style.display = 'block';
    document.getElementById('sessionHistory').style.display = 'block';
    document.getElementById('mandalCreation').style.display = 'none';
}

function handleAddPastSession(event) {
    event.preventDefault();
    const pastDate = new Date(document.getElementById('pastDate').value);
    const addMorning = document.getElementById('morningSession').checked;
    const addEvening = document.getElementById('eveningSession').checked;

    if (isNaN(pastDate.getTime())) {
        showToast('Please select a valid date.');
        return;
    }

    if (addMorning) {
        const morningDate = new Date(pastDate);
        morningDate.setHours(8, 0, 0, 0);
        store.addSession({
            date: morningDate,
            duration: SESSION_DURATION,
            notes: '',
            period: 'Morning'
        });
    }

    if (addEvening) {
        const eveningDate = new Date(pastDate);
        eveningDate.setHours(20, 0, 0, 0);
        store.addSession({
            date: eveningDate,
            duration: SESSION_DURATION,
            notes: '',
            period: 'Evening'
        });
    }

    closeModal('pastSessionModal');
    showToast('Past session(s) added successfully.');
}

function handleSubmitFeedback() {
    const feedbackText = document.getElementById('feedbackText').value.trim();
    if (!feedbackText) {
        showToast('Please enter feedback before submitting.');
        return;
    }
    const feedback = {
        text: feedbackText,
        date: new Date().toISOString()
    };
    let feedbacks = JSON.parse(localStorage.getItem('meditationTrackerFeedback') || '[]');
    feedbacks.push(feedback);
    localStorage.setItem('meditationTrackerFeedback', JSON.stringify(feedbacks));
    document.getElementById('feedbackText').value = '';
    closeModal('feedbackModal');
    showToast('Feedback submitted successfully!');
}

function handleDeleteSession(index) {
    if (confirm('Are you sure you want to delete this session?')) {
        store.deleteSession(index);
        showToast('Session deleted successfully.');
        displaySessionHistory(store.state);
    }
}

function handleSaveNotes(event) {
    const index = parseInt(event.target.dataset.index);
    const notes = event.target.innerHTML; // Use innerHTML to preserve formatting
    store.updateSessionNotes(index, sanitizeHTML(notes));
    showToast('Notes saved successfully.');
}

function handleAddTodaySession() {
    const now = new Date();
    store.addSession({
        date: now,
        duration: SESSION_DURATION,
        notes: '',
        period: getSessionTime(now)
    });
    showToast('Session added for today.');
}

function handleSearch() {
    const query = document.getElementById('searchInput').value;
    const searchResults = store.searchNotes(query);
    displaySessionHistory({ ...store.state, sessions: searchResults }, query);
}

function handleStartSession() {
    store.startTimer();
    updateTimerControls(true);
}

function handleStopSession() {
    store.stopTimer();
    updateTimerControls(false);
    showToast('Session completed and saved.');
}

function handleFormatClick(index) {
    // This function should handle formatting for the specific note
    console.log(`Format options for session ${index}`);
    showToast('Formatting options are under development.');
    // In a full implementation, this would open a formatting menu or apply pre-defined formats
}

function applyFormat(command) {
    document.execCommand(command, false, null);
    // Save the changes for the current active element
    const activeElement = document.activeElement;
    if (activeElement.classList.contains('editable-notes')) {
        handleSaveNotes({ target: activeElement });
    }
}

function showToast(message) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.style.display = 'block';
    setTimeout(() => {
        toast.style.display = 'none';
    }, 3000);
}

function openModal(modalId) {
    document.getElementById(modalId).style.display = 'block';
    document.getElementById(modalId).setAttribute('aria-hidden', 'false');
}

function closeModal(modalId) {
    document.getElementById(modalId).style.display = 'none';
    document.getElementById(modalId).setAttribute('aria-hidden', 'true');
}

// Media Embedding Functions
function handleEmbedMedia() {
    const mediaUrl = document.getElementById('mediaUrl').value.trim();
    const mediaContainer = document.getElementById('mediaContainer');
    
    if (!mediaUrl) {
        showToast('Please enter a valid URL.');
        return;
    }

    try {
        const url = new URL(mediaUrl);
        
        if (url.hostname.includes('youtube.com') || url.hostname.includes('youtu.be')) {
            embedYouTubeVideo(mediaUrl, mediaContainer);
        } else if (url.hostname.includes('soundcloud.com')) {
            embedSoundCloudTrack(mediaUrl, mediaContainer);
        } else {
            showToast('Unsupported media URL. Please enter a YouTube or SoundCloud URL.');
        }
    } catch (error) {
        showToast('Invalid URL. Please check and try again.');
    }
}

function embedYouTubeVideo(url, container) {
    const videoId = extractYouTubeId(url);
    if (videoId) {
        const embedUrl = `https://www.youtube-nocookie.com/embed/${videoId}`;
        const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/0.jpg`;
        const startTime = extractYouTubeStartTime(url);

        container.innerHTML = `
            <div class="youtube-preview">
                <img src="${thumbnailUrl}" alt="Video thumbnail" style="width: 100%; max-width: 480px;">
                <button onclick="playYouTubeVideo('${embedUrl}', ${startTime})" class="play-button">Play Video</button>
            </div>
        `;
        showToast('YouTube video added successfully. Click to play.');
    } else {
        showToast('Invalid YouTube URL. Please check and try again.');
    }
}

function embedSoundCloudTrack(url, container) {
    const embedUrl = `https://w.soundcloud.com/player/?url=${encodeURIComponent(url)}`;
    container.innerHTML = `
        <iframe 
            width="100%" 
            height="166" 
            scrolling="no" 
            frameborder="no" 
            allow="autoplay" 
            src="${embedUrl}"
            title="SoundCloud audio player">
        </iframe>`;
    showToast('SoundCloud track embedded successfully.');
}

function extractYouTubeId(url) {
    const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
    const match = url.match(regExp);
    return (match && match[2].length === 11) ? match[2] : null;
}

function extractYouTubeStartTime(url) {
    const regExp = /[?&]t=(\d+)/;
    const match = url.match(regExp);
    return match ? parseInt(match[1]) : 0;
}

function playYouTubeVideo(embedUrl, startTime) {
    const mediaContainer = document.getElementById('mediaContainer');
    mediaContainer.innerHTML = `
        <iframe 
            width="560" 
            height="315" 
            src="${embedUrl}?autoplay=1&start=${startTime}"
            frameborder="0" 
            allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" 
            allowfullscreen
            title="YouTube video player">
        </iframe>`;
}

// Initialize application
const store = new MeditationStore();

document.addEventListener('DOMContentLoaded', () => {
    store.loadFromLocalStorage();
    
    document.getElementById('themeToggle').addEventListener('click', () => store.toggleTheme());
    document.getElementById('giveFeedback').addEventListener('click', () => openModal('feedbackModal'));
    document.getElementById('addPastSession').addEventListener('click', () => openModal('pastSessionModal'));
    document.getElementById('createMandal').addEventListener('click', handleCreateMandal);
    document.getElementById('sortByDate').addEventListener('click', () => {
        store.toggleSortOrder();
        displaySessionHistory(store.state);
    });
    document.getElementById('submitFeedback').addEventListener('click', handleSubmitFeedback);
    document.getElementById('pastSessionForm').addEventListener('submit', handleAddPastSession);
    document.getElementById('searchInput').addEventListener('input', handleSearch);
    document.getElementById('startSession').addEventListener('click', handleStartSession);
    document.getElementById('stopSession').addEventListener('click', handleStopSession);
    document.getElementById('embedMedia').addEventListener('click', handleEmbedMedia);

    const userNameElement = document.getElementById('userName');
    userNameElement.textContent = store.state.userName;
    userNameElement.addEventListener('blur', (e) => {
        const newName = e.target.textContent.trim();
        if (newName) {
            store.setUserName(sanitizeHTML(newName));
            showToast('Name updated successfully.');
        } else {
            e.target.textContent = store.state.userName;
            showToast('Name cannot be empty.');
        }
    });

    if (store.state.activeMandal) {
        document.getElementById('activeMandalInfo').style.display = 'block';
        document.getElementById('sessionHistory').style.display = 'block';
        document.getElementById('mandalCreation').style.display = 'none';
    }

    updateDashboard(store.state);
    displaySessionHistory(store.state);
    document.body.classList.toggle('dark-mode', store.state.theme === 'dark');

    // Back to Top functionality
    const backToTopButton = document.getElementById('backToTop');
    window.onscroll = function() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            backToTopButton.style.display = "block";
        } else {
            backToTopButton.style.display = "none";
        }
    };

    backToTopButton.addEventListener('click', function() {
        document.body.scrollTop = 0; // For Safari
        document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
    });
});

// Close modals when clicking outside
window.onclick = function(event) {
    if (event.target.classList.contains('modal')) {
        closeModal(event.target.id);
    }
};

// Close modals when pressing Escape key
document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        document.querySelectorAll('.modal').forEach(modal => {
            if (modal.style.display === 'block') {
                closeModal(modal.id);
            }
        });
    }
});

store.addObserver({
    update: function(state) {
        updateDashboard(state);
        displaySessionHistory(state);
        updateTimerControls(state.timerRunning);
        updateTimerDisplay(state.timerSeconds);
    }
});

// Add support for offline functionality
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/mandal-20/service-worker.js')
            .then(registration => {
                console.log('ServiceWorker registration successful with scope: ', registration.scope);
            })
            .catch(err => {
                console.error('ServiceWorker registration failed: ', err);
            });
    });
}

// Cleanup function
window.addEventListener('beforeunload', () => {
    store.cleanup();
});



// This concludes the main JavaScript file for the Meditation Mandal Tracker application.
  </script>
    <script>
// Constants
const SESSION_DURATION = 873; // 14 minutes and 33 seconds in seconds
const TOTAL_SESSIONS = 96; // 48 days * 2 sessions per day

// Utility Functions
const formatDate = (date) => {
    return date.toLocaleDateString('en-GB', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
    });
};

const formatTime = (seconds) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    return `${pad(hours)}:${pad(minutes)}:${pad(secs)}`;
};

const pad = (num) => num.toString().padStart(2, '0');

const sanitizeHTML = (str) => {
    const temp = document.createElement('div');
    temp.textContent = str;
    return temp.innerHTML;
};

const getSessionTime = (date) => {
    const hours = date.getHours();
    return hours < 12 ? 'Morning' : 'Evening';
};

// MeditationStore Class
class MeditationStore {
    constructor() {
        this.state = {
            activeMandal: null,
            sessions: [],
            sortAscending: true,
            theme: 'light',
            timerRunning: false,
            timerSeconds: 0,
            userName: 'Your Name'
        };
        this.observers = [];
        this.timerInterval = null;
        this.timerStartTime = null;
    }

    addObserver(observer) {
        this.observers.push(observer);
    }

    notifyObservers() {
        this.observers.forEach(observer => observer.update(this.state));
    }

    setState(newState) {
        this.state = { ...this.state, ...newState };
        this.saveToLocalStorage();
        this.notifyObservers();
    }

    createMandal(mandalData) {
        if (this.state.activeMandal) {
            throw new Error("An active Mandal already exists. Please complete or delete it before creating a new one.");
        }
        this.setState({ activeMandal: mandalData, sessions: [] });
    }

    addSession(sessionData) {
        this.setState({
            sessions: [...this.state.sessions, sessionData]
        });
    }

    deleteSession(index) {
        const newSessions = [...this.state.sessions];
        newSessions.splice(index, 1);
        this.setState({ sessions: newSessions });
    }

    updateSessionNotes(index, notes) {
        const newSessions = [...this.state.sessions];
        newSessions[index].notes = notes;
        this.setState({ sessions: newSessions });
    }

    toggleSortOrder() {
        this.setState({ sortAscending: !this.state.sortAscending });
    }

    toggleTheme() {
        const newTheme = this.state.theme === 'light' ? 'dark' : 'light';
        this.setState({ theme: newTheme });
        document.body.classList.toggle('dark-mode', newTheme === 'dark');
    }

    saveToLocalStorage() {
        localStorage.setItem('meditationTrackerState', JSON.stringify(this.state));
    }

    loadFromLocalStorage() {
        const savedState = JSON.parse(localStorage.getItem('meditationTrackerState'));
        if (savedState) {
            if (savedState.activeMandal) {
                savedState.activeMandal.startDate = new Date(savedState.activeMandal.startDate);
                savedState.activeMandal.endDate = new Date(savedState.activeMandal.endDate);
            }
            savedState.sessions = savedState.sessions.map(session => ({
                ...session,
                date: new Date(session.date)
            }));
            this.setState(savedState);
        }
    }

    startTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
        }

        this.timerStartTime = Date.now();
        this.setState({ timerRunning: true, timerSeconds: 0 });

        this.timerInterval = setInterval(() => {
            const elapsedSeconds = Math.floor((Date.now() - this.timerStartTime) / 1000);
            this.setState({ timerSeconds: elapsedSeconds });

            if (elapsedSeconds >= SESSION_DURATION) {
                this.stopTimer();
            }
        }, 1000);
    }

    stopTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }

        const elapsedSeconds = Math.floor((Date.now() - this.timerStartTime) / 1000);
        const duration = Math.min(elapsedSeconds, SESSION_DURATION);

        this.addSession({
            date: new Date(this.timerStartTime),
            duration: duration,
            notes: ''
        });

        this.setState({ timerRunning: false, timerSeconds: 0 });
        this.timerStartTime = null;
    }

    cleanup() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
    }

    setUserName(name) {
        this.setState({ userName: name });
    }
}

// UI Update Functions
function updateDashboard(state) {
    const { activeMandal, sessions } = state;
    if (!activeMandal) return;

    const dashboardElement = document.getElementById('dashboard');
    const now = new Date();
    const totalDays = (activeMandal.endDate - activeMandal.startDate) / (1000 * 60 * 60 * 24);
    const daysPassed = Math.max(0, Math.min(totalDays, (now - activeMandal.startDate) / (1000 * 60 * 60 * 24)));
    const progress = Math.round((daysPassed / totalDays) * 100);

    const totalTime = sessions.reduce((sum, session) => sum + session.duration, 0);
    const sessionsCount = sessions.length;

    dashboardElement.innerHTML = `
        <div class="dashboard-item">
            <h3>Mandal Progress</h3>
            <div class="progress-bar" role="progressbar" aria-valuenow="${progress}" aria-valuemin="0" aria-valuemax="100">
                <div class="progress" style="width: ${progress}%;">${progress}%</div>
            </div>
            <p>Start Date: ${formatDate(activeMandal.startDate)}</p>
            <p>End Date: ${formatDate(activeMandal.endDate)}</p>
            <p>Days Remaining: ${Math.max(0, Math.ceil(totalDays - daysPassed))}</p>
        </div>
        <div class="dashboard-item">
            <h3>Session Statistics</h3>
            <p>Total Sessions: ${sessionsCount}/${TOTAL_SESSIONS}</p>
            <p>Total Meditation Time: ${formatTime(totalTime)}</p>
            <p>Average Session Duration: ${formatTime(totalTime / sessionsCount || 0)}</p>
        </div>
    `;

    document.getElementById('activeMandalName').textContent = activeMandal.name;
}

function displaySessionHistory(state) {
    const { sessions, sortAscending } = state;
    const historyContent = document.getElementById('historyContent');
    
    if (sessions.length === 0) {
        historyContent.innerHTML = "<p>No meditation sessions recorded yet.</p>";
        return;
    }

    const sortedSessions = [...sessions].sort((a, b) => 
        sortAscending ? a.date - b.date : b.date - a.date
    );

    historyContent.innerHTML = sortedSessions.map((session, index) => `
        <div class="session-entry">
            <div class="session-header">
                <span class="session-time">${session.period || getSessionTime(session.date)}</span>
                <span class="session-date">${formatDate(session.date)} - ${formatTime(session.duration)}</span>
            </div>
            <div class="editable-notes" contenteditable="true" data-index="${index}" onblur="handleSaveNotes(event)" aria-label="Session notes">
                ${session.notes || 'Add notes here...'}
            </div>
            <div class="session-controls">
                <button class="delete-btn danger-red" onclick="handleDeleteSession(${index})" aria-label="Delete Session">Delete Session</button>
            </div>
        </div>
    `).join('');
}

function updateTimerDisplay(seconds) {
    const timerElement = document.getElementById('timer');
    timerElement.textContent = formatTime(seconds);
}

function updateTimerControls(timerRunning) {
    const startButton = document.getElementById('startSession');
    const stopButton = document.getElementById('stopSession');
    startButton.style.display = timerRunning ? 'none' : 'inline-block';
    stopButton.style.display = timerRunning ? 'inline-block' : 'none';
}

// Event Handlers
function handleCreateMandal() {
    const name = document.getElementById('mandalName').value.trim();
    const duration = parseInt(document.getElementById('mandalDuration').value);
    const startDate = new Date(document.getElementById('startDate').value);
    
    if (!name || isNaN(startDate.getTime())) {
        showToast('Please enter a valid Mandal name and start date.');
        return;
    }
    
    const endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + duration);
    
    store.createMandal({ name, startDate, endDate, duration });
    showToast('Mandal created successfully!');
    
    document.getElementById('activeMandalInfo').style.display = 'block';
    document.getElementById('sessionHistory').style.display = 'block';
    document.getElementById('mandalCreation').style.display = 'none';
}

function handleDeleteSession(index) {
    if (confirm('Are you sure you want to delete this session?')) {
        store.deleteSession(index);
        showToast('Session deleted successfully.');
    }
}

function handleSaveNotes(event) {
    const index = parseInt(event.target.dataset.index);
    const notes = event.target.innerHTML;
    store.updateSessionNotes(index, sanitizeHTML(notes));
    showToast('Notes saved successfully.');
}

function handleStartSession() {
    store.startTimer();
}

function handleStopSession() {
    store.stopTimer();
    showToast('Session completed and saved.');
}

function showToast(message) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.style.display = 'block';
    setTimeout(() => {
        toast.style.display = 'none';
    }, 3000);
}

// Initialize application
const store = new MeditationStore();

document.addEventListener('DOMContentLoaded', () => {
    store.loadFromLocalStorage();
    
    document.getElementById('themeToggle').addEventListener('click', () => store.toggleTheme());
    document.getElementById('createMandal').addEventListener('click', handleCreateMandal);
    document.getElementById('sortByDate').addEventListener('click', () => {
        store.toggleSortOrder();
        displaySessionHistory(store.state);
    });
    document.getElementById('startSession').addEventListener('click', handleStartSession);
    document.getElementById('stopSession').addEventListener('click', handleStopSession);

    const userNameElement = document.getElementById('userName');
    userNameElement.textContent = store.state.userName;
    userNameElement.addEventListener('blur', (e) => {
        const newName = e.target.textContent.trim();
        if (newName) {
            store.setUserName(sanitizeHTML(newName));
            showToast('Name updated successfully.');
        } else {
            e.target.textContent = store.state.userName;
            showToast('Name cannot be empty.');
        }
    });

    if (store.state.activeMandal) {
        document.getElementById('activeMandalInfo').style.display = 'block';
        document.getElementById('sessionHistory').style.display = 'block';
        document.getElementById('mandalCreation').style.display = 'none';
    }

    updateDashboard(store.state);
    displaySessionHistory(store.state);
    document.body.classList.toggle('dark-mode', store.state.theme === 'dark');
});

store.addObserver({
    update: function(state) {
        updateDashboard(state);
        displaySessionHistory(state);
        updateTimerControls(state.timerRunning);
        updateTimerDisplay(state.timerSeconds);
    }
});

// Cleanup function
window.addEventListener('beforeunload', () => {
    store.cleanup();
});
    </script>
    <script>

        // Constants
const SESSION_DURATION = 873; // 14 minutes and 33 seconds in seconds
const TOTAL_SESSIONS = 96; // 48 days * 2 sessions per day

// Utility Functions
const formatDate = (date) => {
    return date.toLocaleDateString('en-GB', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
    });
};

const formatTime = (seconds) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    return `${pad(hours)}:${pad(minutes)}:${pad(secs)}`;
};

const pad = (num) => num.toString().padStart(2, '0');

const sanitizeHTML = (str) => {
    const temp = document.createElement('div');
    temp.textContent = str;
    return temp.innerHTML;
};

const getSessionTime = (date) => {
    const hours = date.getHours();
    return hours < 12 ? 'Morning' : 'Evening';
};

// MeditationStore Class
class MeditationStore {
    constructor() {
        this.state = {
            activeMandal: null,
            sessions: [],
            sortAscending: true,
            theme: 'light',
            timerRunning: false,
            timerSeconds: 0,
            userName: 'Your Name'
        };
        this.observers = [];
        this.timerInterval = null;
        this.timerStartTime = null;
    }

    addObserver(observer) {
        this.observers.push(observer);
    }

    notifyObservers() {
        this.observers.forEach(observer => observer.update(this.state));
    }

    setState(newState) {
        this.state = { ...this.state, ...newState };
        this.saveToLocalStorage();
        this.notifyObservers();
    }

    createMandal(mandalData) {
        if (this.state.activeMandal) {
            throw new Error("An active Mandal already exists. Please complete or delete it before creating a new one.");
        }
        this.setState({ activeMandal: mandalData, sessions: [] });
    }

    addSession(sessionData) {
        this.setState({
            sessions: [...this.state.sessions, sessionData]
        });
    }

    deleteSession(index) {
        const newSessions = [...this.state.sessions];
        newSessions.splice(index, 1);
        this.setState({ sessions: newSessions });
    }

    updateSessionNotes(index, notes) {
        const newSessions = [...this.state.sessions];
        newSessions[index].notes = notes;
        this.setState({ sessions: newSessions });
    }

    toggleSortOrder() {
        this.setState({ sortAscending: !this.state.sortAscending });
    }

    toggleTheme() {
        const newTheme = this.state.theme === 'light' ? 'dark' : 'light';
        this.setState({ theme: newTheme });
        document.body.classList.toggle('dark-mode', newTheme === 'dark');
    }

    saveToLocalStorage() {
        localStorage.setItem('meditationTrackerState', JSON.stringify(this.state));
    }

    loadFromLocalStorage() {
        const savedState = JSON.parse(localStorage.getItem('meditationTrackerState'));
        if (savedState) {
            if (savedState.activeMandal) {
                savedState.activeMandal.startDate = new Date(savedState.activeMandal.startDate);
                savedState.activeMandal.endDate = new Date(savedState.activeMandal.endDate);
            }
            savedState.sessions = savedState.sessions.map(session => ({
                ...session,
                date: new Date(session.date)
            }));
            this.setState(savedState);
        }
    }

    startTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
        }

        this.timerStartTime = Date.now();
        this.setState({ timerRunning: true, timerSeconds: 0 });

        this.timerInterval = setInterval(() => {
            const elapsedSeconds = Math.floor((Date.now() - this.timerStartTime) / 1000);
            this.setState({ timerSeconds: elapsedSeconds });

            if (elapsedSeconds >= SESSION_DURATION) {
                this.stopTimer();
            }
        }, 1000);
    }

    stopTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }

        const elapsedSeconds = Math.floor((Date.now() - this.timerStartTime) / 1000);
        const duration = Math.min(elapsedSeconds, SESSION_DURATION);

        this.addSession({
            date: new Date(this.timerStartTime),
            duration: duration,
            notes: ''
        });

        this.setState({ timerRunning: false, timerSeconds: 0 });
        this.timerStartTime = null;
    }

    cleanup() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
    }

    setUserName(name) {
        this.setState({ userName: name });
    }
}

// UI Update Functions
function updateDashboard(state) {
    const { activeMandal, sessions } = state;
    if (!activeMandal) return;

    const dashboardElement = document.getElementById('dashboard');
    const now = new Date();
    const totalDays = (activeMandal.endDate - activeMandal.startDate) / (1000 * 60 * 60 * 24);
    const daysPassed = Math.max(0, Math.min(totalDays, (now - activeMandal.startDate) / (1000 * 60 * 60 * 24)));
    const progress = Math.round((daysPassed / totalDays) * 100);

    const totalTime = sessions.reduce((sum, session) => sum + session.duration, 0);
    const sessionsCount = sessions.length;

    dashboardElement.innerHTML = `
        <div class="dashboard-item">
            <h3>Mandal Progress</h3>
            <div class="progress-bar" role="progressbar" aria-valuenow="${progress}" aria-valuemin="0" aria-valuemax="100">
                <div class="progress" style="width: ${progress}%;">${progress}%</div>
            </div>
            <p>Start Date: ${formatDate(activeMandal.startDate)}</p>
            <p>End Date: ${formatDate(activeMandal.endDate)}</p>
            <p>Days Remaining: ${Math.max(0, Math.ceil(totalDays - daysPassed))}</p>
        </div>
        <div class="dashboard-item">
            <h3>Session Statistics</h3>
            <p>Total Sessions: ${sessionsCount}/${TOTAL_SESSIONS}</p>
            <p>Total Meditation Time: ${formatTime(totalTime)}</p>
            <p>Average Session Duration: ${formatTime(totalTime / sessionsCount || 0)}</p>
        </div>
    `;

    document.getElementById('activeMandalName').textContent = activeMandal.name;
}

function displaySessionHistory(state) {
    const { sessions, sortAscending } = state;
    const historyContent = document.getElementById('historyContent');
    
    if (sessions.length === 0) {
        historyContent.innerHTML = "<p>No meditation sessions recorded yet.</p>";
        return;
    }

    const sortedSessions = [...sessions].sort((a, b) => 
        sortAscending ? a.date - b.date : b.date - a.date
    );

    historyContent.innerHTML = sortedSessions.map((session, index) => `
        <div class="session-entry">
            <div class="session-header">
                <span class="session-time">${session.period || getSessionTime(session.date)}</span>
                <span class="session-date">${formatDate(session.date)} - ${formatTime(session.duration)}</span>
            </div>
            <div class="editable-notes" contenteditable="true" data-index="${index}" onblur="handleSaveNotes(event)" aria-label="Session notes">
                ${session.notes || 'Add notes here...'}
            </div>
            <div class="session-controls">
                <button class="delete-btn danger-red" onclick="handleDeleteSession(${index})" aria-label="Delete Session">Delete Session</button>
            </div>
        </div>
    `).join('');
}

function updateTimerDisplay(seconds) {
    const timerElement = document.getElementById('timer');
    timerElement.textContent = formatTime(seconds);
}

function updateTimerControls(timerRunning) {
    const startButton = document.getElementById('startSession');
    const stopButton = document.getElementById('stopSession');
    startButton.style.display = timerRunning ? 'none' : 'inline-block';
    stopButton.style.display = timerRunning ? 'inline-block' : 'none';
}

// Event Handlers
function handleCreateMandal() {
    const name = document.getElementById('mandalName').value.trim();
    const duration = parseInt(document.getElementById('mandalDuration').value);
    const startDate = new Date(document.getElementById('startDate').value);
    
    if (!name || isNaN(startDate.getTime())) {
        showToast('Please enter a valid Mandal name and start date.');
        return;
    }
    
    const endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + duration);
    
    store.createMandal({ name, startDate, endDate, duration });
    showToast('Mandal created successfully!');
    
    document.getElementById('activeMandalInfo').style.display = 'block';
    document.getElementById('sessionHistory').style.display = 'block';
    document.getElementById('mandalCreation').style.display = 'none';
}

function handleDeleteSession(index) {
    if (confirm('Are you sure you want to delete this session?')) {
        store.deleteSession(index);
        showToast('Session deleted successfully.');
    }
}

function handleSaveNotes(event) {
    const index = parseInt(event.target.dataset.index);
    const notes = event.target.innerHTML;
    store.updateSessionNotes(index, sanitizeHTML(notes));
    showToast('Notes saved successfully.');
}

function handleStartSession() {
    store.startTimer();
}

function handleStopSession() {
    store.stopTimer();
    showToast('Session completed and saved.');
}

function showToast(message) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.style.display = 'block';
    setTimeout(() => {
        toast.style.display = 'none';
    }, 3000);
}

// Initialize application
const store = new MeditationStore();

document.addEventListener('DOMContentLoaded', () => {
    store.loadFromLocalStorage();
    
    document.getElementById('themeToggle').addEventListener('click', () => store.toggleTheme());
    document.getElementById('createMandal').addEventListener('click', handleCreateMandal);
    document.getElementById('sortByDate').addEventListener('click', () => {
        store.toggleSortOrder();
        displaySessionHistory(store.state);
    });
    document.getElementById('startSession').addEventListener('click', handleStartSession);
    document.getElementById('stopSession').addEventListener('click', handleStopSession);

    const userNameElement = document.getElementById('userName');
    userNameElement.textContent = store.state.userName;
    userNameElement.addEventListener('blur', (e) => {
        const newName = e.target.textContent.trim();
        if (newName) {
            store.setUserName(sanitizeHTML(newName));
            showToast('Name updated successfully.');
        } else {
            e.target.textContent = store.state.userName;
            showToast('Name cannot be empty.');
        }
    });

    if (store.state.activeMandal) {
        document.getElementById('activeMandalInfo').style.display = 'block';
        document.getElementById('sessionHistory').style.display = 'block';
        document.getElementById('mandalCreation').style.display = 'none';
    }

    updateDashboard(store.state);
    displaySessionHistory(store.state);
    document.body.classList.toggle('dark-mode', store.state.theme === 'dark');
});

store.addObserver({
    update: function(state) {
        updateDashboard(state);
        displaySessionHistory(state);
        updateTimerControls(state.timerRunning);
        updateTimerDisplay(state.timerSeconds);
    }
});

// Cleanup function
window.addEventListener('beforeunload', () => {
    store.cleanup();
});
    </script>
